// Auto-generated Jounce Client Bundle
// DO NOT EDIT - Generated by Jounce compiler

import { h, RPCClient, mountComponent } from './client-runtime.js';
import { signal, computed, effect, batch } from './reactivity.js';

// Node.js crypto module (for tests and server-side code)
let __nodeCrypto;
try {
  if (typeof require !== 'undefined') {
    __nodeCrypto = require('crypto');
  }
} catch (e) {
  // crypto module not available (browser environment)
}

// Crypto helpers - use Node.js crypto module when available
const __crypto_sha256 = function(data) {
  if (__nodeCrypto) return __nodeCrypto.createHash('sha256').update(data).digest('hex');
  return ''; // fallback
};
const __crypto_sha1 = function(data) {
  if (__nodeCrypto) return __nodeCrypto.createHash('sha1').update(data).digest('hex');
  return ''; // fallback
};
const __crypto_md5 = function(data) {
  if (__nodeCrypto) return __nodeCrypto.createHash('md5').update(data).digest('hex');
  return ''; // fallback
};
const __crypto_hmac = function(algo, key, data) {
  if (__nodeCrypto) return __nodeCrypto.createHmac(algo, key).update(data).digest('hex');
  return ''; // fallback
};
const __crypto_random_bytes = function(len) {
  if (__nodeCrypto) return Array.from(__nodeCrypto.randomBytes(len));
  return Array(len).fill(0); // fallback
};
const __crypto_pbkdf2 = function(password, salt, iterations, keylen, digest) {
  if (__nodeCrypto) return __nodeCrypto.pbkdf2Sync(password, salt, iterations, keylen, digest).toString('hex');
  return ''; // fallback
};

// Node.js fs module (for server-side file I/O)
let __nodeFs;
try {
  if (typeof require !== 'undefined') {
    __nodeFs = require('fs');
  }
} catch (e) {
  // fs module not available (browser environment)
}

// File system helpers - use Node.js fs module when available
const __fs_read_to_string = function(path) {
  if (__nodeFs) return __nodeFs.readFileSync(path, 'utf8');
  throw new Error('File I/O not available in browser');
};
const __fs_read_bytes = function(path) {
  if (__nodeFs) return Array.from(__nodeFs.readFileSync(path));
  throw new Error('File I/O not available in browser');
};
const __fs_write_string = function(path, data) {
  if (__nodeFs) { __nodeFs.writeFileSync(path, data, 'utf8'); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_write_bytes = function(path, data) {
  if (__nodeFs) { __nodeFs.writeFileSync(path, Buffer.from(data)); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_append_string = function(path, data) {
  if (__nodeFs) { __nodeFs.appendFileSync(path, data, 'utf8'); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_exists = function(path) {
  if (__nodeFs) return __nodeFs.existsSync(path);
  return false;
};
const __fs_metadata = function(path) {
  if (__nodeFs) {
    const stats = __nodeFs.statSync(path);
    const _size = stats.size;
    const _is_file = stats.isFile();
    const _is_directory = stats.isDirectory();
    const _created = stats.birthtimeMs;
    const _modified = stats.mtimeMs;
    const _accessed = stats.atimeMs;
    const _permissions = stats.mode & 0o777;
    return {
      size: _size,
      is_file: () => _is_file,
      is_directory: () => _is_directory,
      created: _created,
      modified: _modified,
      accessed: _accessed,
      permissions: _permissions,
      len: () => _size,
      is_readonly: () => (_permissions & 128) === 0
    };
  }
  throw new Error('File I/O not available in browser');
};
const __fs_read_dir = function(path) {
  if (__nodeFs) {
    const entries = __nodeFs.readdirSync(path, { withFileTypes: true });
    return entries.map(entry => {
      const fullPath = path + '/' + entry.name;
      const stats = __nodeFs.statSync(fullPath);
      const _size = stats.size;
      const _is_file = stats.isFile();
      const _is_directory = stats.isDirectory();
      const metadata = {
        size: _size,
        is_file: _is_file,
        is_directory: _is_directory,
        created: stats.birthtimeMs,
        modified: stats.mtimeMs,
        accessed: stats.atimeMs,
        permissions: stats.mode & 0o777
      };
      return {
        name: entry.name,
        path: fullPath,
        metadata: metadata,
        is_file: () => _is_file,
        is_directory: () => _is_directory
      };
    });
  }
  throw new Error('File I/O not available in browser');
};
const __fs_create_dir = function(path) {
  if (__nodeFs) { __nodeFs.mkdirSync(path); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_create_dir_all = function(path) {
  if (__nodeFs) { __nodeFs.mkdirSync(path, { recursive: true }); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_remove_file = function(path) {
  if (__nodeFs) { __nodeFs.unlinkSync(path); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_remove_dir = function(path) {
  if (__nodeFs) { __nodeFs.rmdirSync(path); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_remove_dir_all = function(path) {
  if (__nodeFs) { __nodeFs.rmSync(path, { recursive: true, force: true }); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_rename = function(from, to) {
  if (__nodeFs) { __nodeFs.renameSync(from, to); return; }
  throw new Error('File I/O not available in browser');
};
const __fs_read_to_string_safe = function(path) {
  try { return Ok(__fs_read_to_string(path)); } catch (e) { return Err(e.message); }
};
const __fs_read_bytes_safe = function(path) {
  try { return Ok(__fs_read_bytes(path)); } catch (e) { return Err(e.message); }
};
const __fs_write_string_safe = function(path, data) {
  try { __fs_write_string(path, data); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_write_bytes_safe = function(path, data) {
  try { __fs_write_bytes(path, data); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_append_string_safe = function(path, data) {
  try { __fs_append_string(path, data); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_metadata_safe = function(path) {
  try { return Ok(__fs_metadata(path)); } catch (e) { return Err(e.message); }
};
const __fs_read_dir_safe = function(path) {
  try { return Ok(__fs_read_dir(path)); } catch (e) { return Err(e.message); }
};
const __fs_create_dir_safe = function(path) {
  try { __fs_create_dir(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_create_dir_all_safe = function(path) {
  try { __fs_create_dir_all(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_remove_file_safe = function(path) {
  try { __fs_remove_file(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_remove_dir_safe = function(path) {
  try { __fs_remove_dir(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_remove_dir_all_safe = function(path) {
  try { __fs_remove_dir_all(path); return Ok(undefined); } catch (e) { return Err(e.message); }
};
const __fs_rename_safe = function(from, to) {
  try { __fs_rename(from, to); return Ok(undefined); } catch (e) { return Err(e.message); }
};

// Built-in type extensions
const Vec = Array; // Vec<T> is Array in JavaScript
Vec.new = function() { return []; }; // Vec::new() creates empty array
// String methods - ensure they work on both primitives and String objects
if (!String.prototype.len) {
  String.prototype.len = function() { return this.length; };
}
if (!String.prototype.is_empty) {
  String.prototype.is_empty = function() { return this.length === 0; };
}
if (!String.prototype.chars) {
  String.prototype.chars = function() { return this.split(''); };
}
if (!String.prototype.contains) {
  String.prototype.contains = function(substr) { return this.includes(substr); };
}
if (!String.prototype.starts_with) {
  String.prototype.starts_with = function(prefix) { return this.startsWith(prefix); };
}
if (!String.prototype.ends_with) {
  String.prototype.ends_with = function(suffix) { return this.endsWith(suffix); };
}
if (!String.prototype.to_lowercase) {
  String.prototype.to_lowercase = function() { return this.toLowerCase(); };
}
if (!String.prototype.char_code_at) {
  String.prototype.char_code_at = function(index) { return this.charCodeAt(index); };
}
if (!String.prototype.char_at) {
  String.prototype.char_at = function(index) { return this.charAt(index); };
}
if (!String.prototype.parse_int) {
  String.prototype.parse_int = function() { return parseInt(this, 10); };
}
if (!String.prototype.parse_float) {
  String.prototype.parse_float = function() { return parseFloat(this); };
}
if (!String.prototype.index_of) {
  String.prototype.index_of = function(substr) { return this.indexOf(substr); };
}
if (!String.prototype.clone) {
  String.prototype.clone = function() { return this.toString(); };
}
if (!String.prototype.push_str) {
  String.prototype.push_str = function(s) { return this + s; };
}
if (!String.prototype.to_string) {
  String.prototype.to_string = function() { return this.toString(); };
}
if (!Number.prototype.to_string) {
  Number.prototype.to_string = function() { return this.toString(); };
}
if (!Array.prototype.len) {
  Array.prototype.len = function() { return this.length; };
}
if (!Array.prototype.is_empty) {
  Array.prototype.is_empty = function() { return this.length === 0; };
}
if (!Array.prototype.clone) {
  Array.prototype.clone = function() { return this.slice(); };
}
if (!Object.prototype.keys) {
  Object.prototype.keys = function() { return Object.keys(this); };
}
if (!Object.prototype.clone) {
  Object.prototype.clone = function() { return JSON.parse(JSON.stringify(this)); };
}
if (!String.from_char_code) {
  String.from_char_code = function(code) { return String.fromCharCode(code); };
}
if (!String.new) {
  String.new = function() {
    const sb = { __value: "" };
    sb.push_str = function(s) { this.__value += s; };
    sb.toString = function() { return this.__value; };
    sb.valueOf = function() { return this.__value; };
    sb.clone = function() { return this.__value; };
    sb.len = function() { return this.__value.length; };
    sb.is_empty = function() { return this.__value.length === 0; };
    sb.contains = function(s) { return this.__value.includes(s); };
    sb.trim = function() { return this.__value.trim(); };
    sb.starts_with = function(s) { return this.__value.startsWith(s); };
    sb.ends_with = function(s) { return this.__value.endsWith(s); };
    sb.substring = function(start, end) { return this.__value.substring(start, end); };
    return sb;
  };
}
if (!String.from) {
  String.from = function(s) { return String(s); };
}

// Result<T, E> enum - represents success (Ok) or failure (Err)
const Result = { __proto__: null };
Result.prototype = {};
function Ok(data) { const v = { variant: "Ok", data: data }; v.__proto__ = Result.prototype; return v; }
function Err(data) { const v = { variant: "Err", data: data }; v.__proto__ = Result.prototype; return v; }
Result.prototype.is_ok = function() { return this.variant === "Ok"; };
Result.prototype.is_err = function() { return this.variant === "Err"; };
Result.prototype.unwrap = function() { if (this.variant === "Ok") return this.data; throw new Error("Called unwrap on Err"); };
Result.prototype.unwrap_err = function() { if (this.variant === "Err") return this.data; throw new Error("Called unwrap_err on Ok"); };
Result.prototype.unwrap_or = function(default_val) { return this.variant === "Ok" ? this.data : default_val; };
Result.Ok = Ok;
Result.Err = Err;

// Option<T> enum - represents Some value or None
const Option = { __proto__: null };
Option.prototype = {};
function Some(data) { const v = { variant: "Some", data: data }; v.__proto__ = Option.prototype; return v; }
const None = (() => { const v = { variant: "None" }; v.__proto__ = Option.prototype; return v; })();
Option.Some = Some;
Option.None = None;
Option.prototype.is_some = function() { return this.variant === "Some"; };
Option.prototype.is_none = function() { return this.variant === "None"; };
Option.prototype.unwrap = function() { if (this.variant === "Some") return this.data; throw new Error("Called unwrap on None"); };
Option.prototype.unwrap_or = function(default_val) { return this.variant === "Some" ? this.data : default_val; };

// HashMap<K, V> is a JavaScript Map
const HashMap = Map;
HashMap.new = function() { return new Map(); };
if (!Map.prototype.insert) {
  Map.prototype.insert = function(k, v) { this.set(k, v); };
}
if (!Map.prototype.contains_key) {
  Map.prototype.contains_key = function(k) { return this.has(k); };
}
if (!Map.prototype.get_or_default) {
  Map.prototype.get_or_default = function(k, def) { return this.has(k) ? this.get(k) : def; };
}
if (!Map.prototype.len) {
  Map.prototype.len = function() { return this.size; };
}
if (!Map.prototype.is_empty) {
  Map.prototype.is_empty = function() { return this.size === 0; };
}

// RPC Client Setup
// Auto-generated RPC client stubs
const client = new RPCClient(window.location.origin + '/_rpc');


// Struct definitions
// Enum definitions
// Implementations
// Client function implementations
// Shared utility functions
export function Stopwatch() {
  return h('div', { class: "stopwatch-card" }, h('h1', { class: "title" }, "⏱️ Stopwatch"), h('div', { class: "time-display", id: "time" }, "00:00.00"), h('div', { class: "status", id: "status" }, "Ready"), h('div', { class: "button-group" }, h('button', { class: "btn btn-start", id: "start-btn" }, "Start"), h('button', { class: "btn btn-stop", id: "stop-btn" }, "Stop"), h('button', { class: "btn btn-reset", id: "reset-btn" }, "Reset")));

}

export function main() {
  return console.log("⏱️ Stopwatch app starting...");

}

// Stdlib module namespaces
const json = {
  parse: typeof parse !== 'undefined' ? parse : undefined,
  stringify: typeof stringify !== 'undefined' ? stringify : undefined,
  stringify_pretty: typeof stringify_pretty !== 'undefined' ? stringify_pretty : undefined,
  // Helper functions for creating JSON values
  null_: () => ({ variant: 'Null' }),
  bool: (b) => ({ variant: 'Bool', data: b }),
  number: (n) => ({ variant: 'Number', data: n }),
  string: (s) => ({ variant: 'String', data: s }),
  array: (arr) => ({ variant: 'Array', data: arr || [] }),
  object: (obj) => ({ variant: 'Object', data: obj || {} }),
};

const crypto = {
  sha256: typeof sha256 !== 'undefined' ? sha256 : undefined,
  sha1: typeof sha1 !== 'undefined' ? sha1 : undefined,
  md5: typeof md5 !== 'undefined' ? md5 : undefined,
  hmac_sha256: typeof hmac_sha256 !== 'undefined' ? hmac_sha256 : undefined,
  random_bytes: typeof random_bytes !== 'undefined' ? random_bytes : undefined,
  random_int: typeof random_int !== 'undefined' ? random_int : undefined,
  random_float: typeof random_float !== 'undefined' ? random_float : undefined,
  random_string: typeof random_string !== 'undefined' ? random_string : undefined,
  random_alphanumeric: typeof random_alphanumeric !== 'undefined' ? random_alphanumeric : undefined,
  random_hex: typeof random_hex !== 'undefined' ? random_hex : undefined,
  uuid_v4: typeof uuid_v4 !== 'undefined' ? uuid_v4 : undefined,
  base64_encode: typeof base64_encode !== 'undefined' ? base64_encode : undefined,
  base64_decode: typeof base64_decode !== 'undefined' ? base64_decode : undefined,
  hex_encode: typeof hex_encode !== 'undefined' ? hex_encode : undefined,
  hex_decode: typeof hex_decode !== 'undefined' ? hex_decode : undefined,
  hash_password_auto: typeof hash_password_auto !== 'undefined' ? hash_password_auto : undefined,
  generate_salt: typeof generate_salt !== 'undefined' ? generate_salt : undefined,
};

const fs = {
  read_to_string: typeof read_to_string !== 'undefined' ? read_to_string : undefined,
  read: typeof read !== 'undefined' ? read : undefined,
  write: typeof write !== 'undefined' ? write : undefined,
  write_bytes: typeof write_bytes !== 'undefined' ? write_bytes : undefined,
  append: typeof append !== 'undefined' ? append : undefined,
  exists: typeof exists !== 'undefined' ? exists : undefined,
  is_file: typeof is_file !== 'undefined' ? is_file : undefined,
  is_directory: typeof is_directory !== 'undefined' ? is_directory : undefined,
  metadata: typeof metadata !== 'undefined' ? metadata : undefined,
  create_dir: typeof create_dir !== 'undefined' ? create_dir : undefined,
  create_dir_all: typeof create_dir_all !== 'undefined' ? create_dir_all : undefined,
  remove_file: typeof remove_file !== 'undefined' ? remove_file : undefined,
  remove_dir: typeof remove_dir !== 'undefined' ? remove_dir : undefined,
  remove_dir_all: typeof remove_dir_all !== 'undefined' ? remove_dir_all : undefined,
  read_dir: typeof read_dir !== 'undefined' ? read_dir : undefined,
  copy: typeof copy !== 'undefined' ? copy : undefined,
  rename: typeof rename !== 'undefined' ? rename : undefined,
  current_dir: typeof current_dir !== 'undefined' ? current_dir : undefined,
  set_current_dir: typeof set_current_dir !== 'undefined' ? set_current_dir : undefined,
  canonicalize: typeof canonicalize !== 'undefined' ? canonicalize : undefined,
  symlink: typeof symlink !== 'undefined' ? symlink : undefined,
  read_link: typeof read_link !== 'undefined' ? read_link : undefined,
  set_permissions: typeof set_permissions !== 'undefined' ? set_permissions : undefined,
  walk_dir: typeof walk_dir !== 'undefined' ? walk_dir : undefined,
  glob: typeof glob !== 'undefined' ? glob : undefined,
};

const yaml = {
  parse: typeof yaml_parse !== 'undefined' ? yaml_parse : undefined,
  stringify: typeof yaml_stringify !== 'undefined' ? yaml_stringify : undefined,
  // Helper functions for creating YAML values
  yaml_null: typeof yaml_null !== 'undefined' ? yaml_null : undefined,
  yaml_bool: typeof yaml_bool !== 'undefined' ? yaml_bool : undefined,
  yaml_number: typeof yaml_number !== 'undefined' ? yaml_number : undefined,
  yaml_string: typeof yaml_string !== 'undefined' ? yaml_string : undefined,
  yaml_sequence: typeof yaml_sequence !== 'undefined' ? yaml_sequence : undefined,
  yaml_mapping: typeof yaml_mapping !== 'undefined' ? yaml_mapping : undefined,
};

// UI Components
// Initialize application
window.addEventListener('DOMContentLoaded', () => {
  console.log('Jounce client initialized');

  // Mount the Stopwatch component
  mountComponent(Stopwatch);

  // Create reactive state
  const elapsed = signal(0);  // milliseconds
  const isRunning = signal(false);
  let intervalId = null;

  // Get DOM elements
  const timeDisplay = document.getElementById('time');
  const statusDisplay = document.getElementById('status');
  const startBtn = document.getElementById('start-btn');
  const stopBtn = document.getElementById('stop-btn');
  const resetBtn = document.getElementById('reset-btn');

  // Format time as MM:SS.ms
  function formatTime(ms) {
    const minutes = Math.floor(ms / 60000);
    const seconds = Math.floor((ms % 60000) / 1000);
    const centiseconds = Math.floor((ms % 1000) / 10);
    return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(centiseconds).padStart(2, '0')}`;
  }

  // Event listeners
  if (startBtn) {
    startBtn.addEventListener('click', () => {
      if (!isRunning.value) {
        isRunning.value = true;
        const startTime = Date.now() - elapsed.value;
        intervalId = setInterval(() => {
          elapsed.value = Date.now() - startTime;
        }, 10); // Update every 10ms
      }
    });
  }

  if (stopBtn) {
    stopBtn.addEventListener('click', () => {
      if (isRunning.value && intervalId) {
        isRunning.value = false;
        clearInterval(intervalId);
        intervalId = null;
      }
    });
  }

  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
      isRunning.value = false;
      elapsed.value = 0;
    });
  }

  // Effects to update UI
  effect(() => {
    if (timeDisplay) {
      timeDisplay.textContent = formatTime(elapsed.value);
    }
  });

  effect(() => {
    if (statusDisplay) {
      statusDisplay.textContent = isRunning.value ? 'Running...' : 'Stopped';
    }
  });

  effect(() => {
    if (startBtn) startBtn.disabled = isRunning.value;
    if (stopBtn) stopBtn.disabled = !isRunning.value;
  });

  console.log('✅ Stopwatch app initialized!');
});

//# sourceMappingURL=client.js.map
