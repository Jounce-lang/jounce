// Test: Functions and closures
fn add(a: i32, b: i32) -> i32 {
    return a + b;
}

fn accepts_callback(callback: fn()) {
    callback();
}

fn accepts_typed_callback(f: fn(i32) -> i32) {
    let result = f(10);
}

fn main() {
    // Regular function call
    let sum = add(5, 3);

    // Closure without types
    let multiply = |x, y| x * y;
    let product = multiply(4, 5);

    // Closure with types
    let typed_closure = (x: i32, y: i32) => x + y;
    let result = typed_closure(2, 3);

    // Closure as argument
    let square = |n| n * n;
    accepts_typed_callback(square);

    // Method chaining
    let chained = "test".to_uppercase().trim();

    // Turbofish (generic type parameters)
    let parsed = "42".parse::<i32>();

    return 0;
}
